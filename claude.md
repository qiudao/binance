# 币安K线数据获取工具 - 修改记录

## 2025-11-22 修改记录

### 一、时间显示改为北京时间

#### 修改内容
将程序中所有时间显示从UTC时间改为北京时间（UTC+8）。

#### 具体修改文件

1. **main.go**
   - 添加北京时区常量 (main.go:21)
   - CSV保存时转换为北京时间 (main.go:215, 221)
   - 屏幕打印时转换为北京时间并标注 (main.go:268-270)

2. **examples/rsi_macd_demo.go**
   - 添加北京时区常量
   - 读取CSV时明确指定北京时区 (使用ParseInLocation)
   - 显示时间时转换为北京时间

3. **indicators/strategy.go**
   - 添加北京时区常量
   - 交易信号输出时转换为北京时间

#### 时区说明
- **UTC时间**：世界协调时间（Coordinated Universal Time）
- **北京时间**：中国标准时间（China Standard Time, CST），UTC+8
- **换算关系**：北京时间 = UTC时间 + 8小时

---

### 二、修复CSV文件保存模式

#### 问题
原代码使用`os.O_APPEND`追加模式，导致每次运行都在文件末尾追加数据，造成数据重复。

#### 解决方案
修改为`os.Create`覆盖模式，每次保存时覆盖旧文件（main.go:184）。

```go
// 修改前（追加模式）
file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

// 修改后（覆盖模式）
file, err := os.Create(filename)
```

---

### 三、修复批量获取数据顺序问题

#### 问题
批量获取多批次数据时，直接按批次顺序append，导致数据顺序混乱：
```
allKlines = [批次1(旧→新), 批次2(更旧→旧), 批次3(更更旧→更旧), ...]
```

#### 解决方案
在`GetKlinesBatch`函数中，获取完所有批次后，按时间戳排序（从新到旧）：

```go
// 按时间从新到旧排序（最新的在前面）
sort.Slice(allKlines, func(i, j int) bool {
    return allKlines[i].OpenTime > allKlines[j].OpenTime
})
```

添加了`sort`包的import (main.go:12)。

---

### 四、修复demo程序时区解析问题

#### 问题
CSV中存储的是北京时间字符串，但demo程序使用`time.Parse`解析时，默认当作UTC时间，然后显示时再加8小时，导致时间多加了8小时。

#### 解决方案
使用`time.ParseInLocation`明确指定时区为北京时间：

```go
// 修改前
openTime, err := time.Parse("2006-01-02 15:04:05", record[2])

// 修改后
openTime, err := time.ParseInLocation("2006-01-02 15:04:05", record[2], BeijingLocation)
```

---

### 使用示例

```bash
# 保存5000条1分钟K线数据（时间为北京时间）
make save-1m

# 查看最新数据（时间为北京时间）
make fetch-1m

# 运行技术指标分析（会先更新数据）
make demo-indicators
```

---

### 验证结果

#### 数据文件验证
```bash
# 数据量：5001行（1行表头 + 5000条数据）
# 最新数据：2025-11-22 13:25:00（北京时间）
# 最旧数据：2025-11-19 02:06:00（北京时间）
# 时间跨度：约3.5天（5000分钟）
# 数据排序：从新到旧完美有序
```

#### 指标分析验证
```bash
make demo-indicators

# 输出示例：
# 最后5根K线的指标：
# 2025-11-22 13:21 (北京时间)
# 2025-11-22 13:22 (北京时间)
# 2025-11-22 13:23 (北京时间)
# 2025-11-22 13:24 (北京时间)
# 2025-11-22 13:25 (北京时间)
```

所有时间显示均为北京时间，与当前实际时间一致！✅

---

## 2025-11-22 RSI14计算验证

### 验证背景
用户质疑RSI14指标计算是否正确，要求验证计算逻辑。

### 验证方法

#### 1. 使用标准算法手动计算
编写了`verify_rsi_ema.go`程序，使用标准的**Wilder's Smoothing**方法计算RSI：

```go
// RSI计算公式
RS = 平均涨幅 / 平均跌幅
RSI = 100 - (100 / (1 + RS))

// Wilder's Smoothing（指数移动平均）
新平均 = (旧平均 * (period-1) + 新值) / period
```

#### 2. 与talib库计算结果对比
对比最后30条K线的RSI值：

| 时间 | talib RSI | 手动计算RSI | 差值 |
|------|-----------|-------------|------|
| 2025-11-22 13:26 | 45.75 | 45.75 | 0.00 ✓ |
| 2025-11-22 13:27 | 47.04 | 47.04 | 0.00 ✓ |
| 2025-11-22 13:28 | 49.39 | 49.39 | 0.00 ✓ |
| 2025-11-22 13:29 | 51.56 | 51.56 | 0.00 ✓ |
| 2025-11-22 13:30 | 50.42 | 50.42 | 0.00 ✓ |

**最大差值：0.0000**

### 验证结果

✅ **RSI14计算完全正确！**

#### 价格与RSI关系验证

| 时间 | 收盘价 | 价格变化 | RSI14 | 市场状态 |
|------|--------|----------|-------|----------|
| 13:21 | 83920.00 | - | 35.33 | 偏弱 |
| 13:22 | 83990.54 | +70.54 | 41.69 | 偏弱 ↑ |
| 13:23 | 83924.00 | -66.54 | 37.90 | 偏弱 ↓ |
| 13:24 | 83961.03 | +37.03 | 41.11 | 偏弱 ↑ |
| 13:25 | 83972.76 | +11.73 | 42.13 | 偏弱 ↑ |
| 13:26 | 84014.75 | +41.99 | 45.75 | 中性 ↑ |
| 13:27 | 84029.95 | +15.20 | 47.04 | 中性 ↑ |
| 13:28 | 84057.49 | +27.54 | 49.39 | 中性 ↑ (金叉)|
| 13:29 | 84083.31 | +25.82 | 51.56 | 中性 ↑ |
| 13:30 | 84070.67 | -12.64 | 50.42 | 中性 ↓ |

**结论：**
- ✅ RSI值与价格变化**完全一致**
- ✅ 价格连续上涨时，RSI从35.33平滑上升至51.56
- ✅ 价格回落时，RSI也相应回落至50.42
- ✅ RSI准确反映了市场强弱变化

### 技术细节

#### RSI计算使用的算法
- **库**：`github.com/markcheno/go-talib`
- **方法**：Wilder's Smoothing（标准RSI算法）
- **周期**：14
- **数据顺序**：从旧到新（正确）

#### 关键代码位置
- 指标计算：`indicators/indicators.go:53`
- 数据反转：`examples/rsi_macd_demo.go:133-136`
- talib调用：`talib.Rsi(closes, 14)`

### 常见误解

⚠️ **注意**：简单移动平均(SMA)和Wilder's Smoothing计算的RSI会有**显著差异**（可能相差6+点）。标准RSI使用Wilder's Smoothing，不是SMA！

```
示例（13:30数据）：
- SMA方法计算：RSI = 56.73
- Wilder's方法计算：RSI = 50.42 ✓ (正确)
- 差值：6.30
```
