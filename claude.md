# 币安K线数据获取工具 - 修改记录

## 2025-11-22 修改记录

### 一、时间显示改为北京时间

#### 修改内容
将程序中所有时间显示从UTC时间改为北京时间（UTC+8）。

#### 具体修改文件

1. **main.go**
   - 添加北京时区常量 (main.go:21)
   - CSV保存时转换为北京时间 (main.go:215, 221)
   - 屏幕打印时转换为北京时间并标注 (main.go:268-270)

2. **examples/rsi_macd_demo.go**
   - 添加北京时区常量
   - 读取CSV时明确指定北京时区 (使用ParseInLocation)
   - 显示时间时转换为北京时间

3. **indicators/strategy.go**
   - 添加北京时区常量
   - 交易信号输出时转换为北京时间

#### 时区说明
- **UTC时间**：世界协调时间（Coordinated Universal Time）
- **北京时间**：中国标准时间（China Standard Time, CST），UTC+8
- **换算关系**：北京时间 = UTC时间 + 8小时

---

### 二、修复CSV文件保存模式

#### 问题
原代码使用`os.O_APPEND`追加模式，导致每次运行都在文件末尾追加数据，造成数据重复。

#### 解决方案
修改为`os.Create`覆盖模式，每次保存时覆盖旧文件（main.go:184）。

```go
// 修改前（追加模式）
file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

// 修改后（覆盖模式）
file, err := os.Create(filename)
```

---

### 三、修复批量获取数据顺序问题

#### 问题
批量获取多批次数据时，直接按批次顺序append，导致数据顺序混乱：
```
allKlines = [批次1(旧→新), 批次2(更旧→旧), 批次3(更更旧→更旧), ...]
```

#### 解决方案
在`GetKlinesBatch`函数中，获取完所有批次后，按时间戳排序（从新到旧）：

```go
// 按时间从新到旧排序（最新的在前面）
sort.Slice(allKlines, func(i, j int) bool {
    return allKlines[i].OpenTime > allKlines[j].OpenTime
})
```

添加了`sort`包的import (main.go:12)。

---

### 四、修复demo程序时区解析问题

#### 问题
CSV中存储的是北京时间字符串，但demo程序使用`time.Parse`解析时，默认当作UTC时间，然后显示时再加8小时，导致时间多加了8小时。

#### 解决方案
使用`time.ParseInLocation`明确指定时区为北京时间：

```go
// 修改前
openTime, err := time.Parse("2006-01-02 15:04:05", record[2])

// 修改后
openTime, err := time.ParseInLocation("2006-01-02 15:04:05", record[2], BeijingLocation)
```

---

### 使用示例

```bash
# 保存5000条1分钟K线数据（时间为北京时间）
make save-1m

# 查看最新数据（时间为北京时间）
make fetch-1m

# 运行技术指标分析（会先更新数据）
make demo-indicators
```

---

### 验证结果

#### 数据文件验证
```bash
# 数据量：5001行（1行表头 + 5000条数据）
# 最新数据：2025-11-22 13:25:00（北京时间）
# 最旧数据：2025-11-19 02:06:00（北京时间）
# 时间跨度：约3.5天（5000分钟）
# 数据排序：从新到旧完美有序
```

#### 指标分析验证
```bash
make demo-indicators

# 输出示例：
# 最后5根K线的指标：
# 2025-11-22 13:21 (北京时间)
# 2025-11-22 13:22 (北京时间)
# 2025-11-22 13:23 (北京时间)
# 2025-11-22 13:24 (北京时间)
# 2025-11-22 13:25 (北京时间)
```

所有时间显示均为北京时间，与当前实际时间一致！✅

---

## 2025-11-22 RSI14计算验证

### 验证背景
用户质疑RSI14指标计算是否正确，要求验证计算逻辑。

### 验证方法

#### 1. 使用标准算法手动计算
编写了`verify_rsi_ema.go`程序，使用标准的**Wilder's Smoothing**方法计算RSI：

```go
// RSI计算公式
RS = 平均涨幅 / 平均跌幅
RSI = 100 - (100 / (1 + RS))

// Wilder's Smoothing（指数移动平均）
新平均 = (旧平均 * (period-1) + 新值) / period
```

#### 2. 与talib库计算结果对比
对比最后30条K线的RSI值：

| 时间 | talib RSI | 手动计算RSI | 差值 |
|------|-----------|-------------|------|
| 2025-11-22 13:26 | 45.75 | 45.75 | 0.00 ✓ |
| 2025-11-22 13:27 | 47.04 | 47.04 | 0.00 ✓ |
| 2025-11-22 13:28 | 49.39 | 49.39 | 0.00 ✓ |
| 2025-11-22 13:29 | 51.56 | 51.56 | 0.00 ✓ |
| 2025-11-22 13:30 | 50.42 | 50.42 | 0.00 ✓ |

**最大差值：0.0000**

### 验证结果

✅ **RSI14计算完全正确！**

#### 价格与RSI关系验证

| 时间 | 收盘价 | 价格变化 | RSI14 | 市场状态 |
|------|--------|----------|-------|----------|
| 13:21 | 83920.00 | - | 35.33 | 偏弱 |
| 13:22 | 83990.54 | +70.54 | 41.69 | 偏弱 ↑ |
| 13:23 | 83924.00 | -66.54 | 37.90 | 偏弱 ↓ |
| 13:24 | 83961.03 | +37.03 | 41.11 | 偏弱 ↑ |
| 13:25 | 83972.76 | +11.73 | 42.13 | 偏弱 ↑ |
| 13:26 | 84014.75 | +41.99 | 45.75 | 中性 ↑ |
| 13:27 | 84029.95 | +15.20 | 47.04 | 中性 ↑ |
| 13:28 | 84057.49 | +27.54 | 49.39 | 中性 ↑ (金叉)|
| 13:29 | 84083.31 | +25.82 | 51.56 | 中性 ↑ |
| 13:30 | 84070.67 | -12.64 | 50.42 | 中性 ↓ |

**结论：**
- ✅ RSI值与价格变化**完全一致**
- ✅ 价格连续上涨时，RSI从35.33平滑上升至51.56
- ✅ 价格回落时，RSI也相应回落至50.42
- ✅ RSI准确反映了市场强弱变化

### 技术细节

#### RSI计算使用的算法
- **库**：`github.com/markcheno/go-talib`
- **方法**：Wilder's Smoothing（标准RSI算法）
- **周期**：14
- **数据顺序**：从旧到新（正确）

#### 关键代码位置
- 指标计算：`indicators/indicators.go:53`
- 数据反转：`examples/rsi_macd_demo.go:133-136`
- talib调用：`talib.Rsi(closes, 14)`

### 常见误解

⚠️ **注意**：简单移动平均(SMA)和Wilder's Smoothing计算的RSI会有**显著差异**（可能相差6+点）。标准RSI使用Wilder's Smoothing，不是SMA！

```
示例（13:30数据）：
- SMA方法计算：RSI = 56.73
- Wilder's方法计算：RSI = 50.42 ✓ (正确)
- 差值：6.30
```

---

## 2025-11-22 背离检测功能

### 功能概述

**背离(Divergence)**是指价格走势与技术指标走势相反的现象，是强烈的反转信号。

### 背离类型

#### 1. 看涨背离（Bullish Divergence）
**条件：**
- ✅ 连续两个LONG信号，时间间隔 ≤ 30分钟
- ✅ 第二次价格更低（下跌 ≥ 0.1%）← 价格创新低
- ✅ 第二次RSI更高 ← RSI未创新低（反而更强）
- ✅ 第二次MACD更高 ← MACD未创新低（反而更强）

**说明：** 价格在下跌，但技术指标在走强 → **强烈买入信号！**

**示例：**
```
信号1: 2025-11-22 10:26 | 价格=84722 | RSI=43.88 | MACD=-82.98
信号2: 2025-11-22 10:45 | 价格=84443 | RSI=48.50 | MACD=-70.00
       价格↓(-0.33%)  RSI↑(+4.62)  MACD↑(+12.98)
       → 看涨背离！价格虽跌，但动能在增强
```

#### 2. 看跌背离（Bearish Divergence）
**条件：**
- ✅ 连续两个SHORT信号，时间间隔 ≤ 30分钟
- ✅ 第二次价格更高（上涨 ≥ 0.1%）← 价格创新高
- ✅ 第二次RSI更低 ← RSI未创新高（反而更弱）
- ✅ 第二次MACD更低 ← MACD未创新高（反而更弱）

**说明：** 价格在上涨，但技术指标在走弱 → **强烈卖出信号！**

**示例：**
```
信号1: 2025-11-22 07:36 | 价格=84924 | RSI=56.61 | MACD=133.80
信号2: 2025-11-22 07:47 | 价格=85140 | RSI=52.30 | MACD=118.50
       价格↑(+0.25%)  RSI↓(-4.31)  MACD↓(-15.30)
       → 看跌背离！价格虽涨，但动能在减弱
```

### 检测参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 时间间隔 | ≤ 30分钟 | 两个信号间隔不超过30分钟 |
| 价格变化 | ≥ 0.1% | 价格变化至少0.1%（约84元）|
| 背离条件 | RSI和MACD都背离 | 两个指标必须都满足背离条件 |

### 实现文件

#### 1. `indicators/strategy.go`（新增）
- `DivergenceType` 枚举
- `DivergenceSignal` 结构体
- `DetectDivergence()` 函数
- `String()` 格式化方法

#### 2. `examples/rsi_macd_demo.go`（修改）
- 调用 `indicators.DetectDivergence(signals)`
- 单独输出背离信号列表
- 统计看涨/看跌背离数量

### 使用方法

```bash
# 运行技术指标分析（包含背离检测）
make demo-indicators
```

### 输出示例

```
=== 检测背离信号 ===
发现 5 个背离信号（强烈反转信号！）：

[看涨背离] 2025-11-22 10:45:59 | 间隔: 19分钟 | 价格: 84722.35→84443.59 (-0.33%) | RSI: 43.88→48.50 (+4.62) | MACD: -82.9805→-70.0000 (+12.9805)
[看跌背离] 2025-11-22 07:47:59 | 间隔: 11分钟 | 价格: 84924.36→85140.36 (+0.25%) | RSI: 56.61→52.30 (-4.31) | MACD: 133.7984→118.5000 (-15.2984)

=== 背离统计 ===
看涨背离: 3 个（价格下跌，指标上涨 → 强烈买入信号！）
看跌背离: 2 个（价格上涨，指标下跌 → 强烈卖出信号！）

💡 背离信号强度高于普通信号，建议重点关注！
```

### 技术原理

**背离的本质：** 价格与动能的分离

- **看涨背离**：价格虽然在创新低，但市场抛压减弱，买盘增强
  - 虽然价格还在下跌，但RSI/MACD反而上升
  - 说明下跌动能衰竭，即将反转向上

- **看跌背离**：价格虽然在创新高，但市场买盘减弱，抛压增强
  - 虽然价格还在上涨，但RSI/MACD反而下降
  - 说明上涨动能衰竭，即将反转向下

### 关键代码位置

- 背离检测算法：`indicators/strategy.go:218-298`
- 背离输出逻辑：`examples/rsi_macd_demo.go:70-99`

### 注意事项

⚠️ **背离信号的特点：**
1. 强度高：背离是强烈的反转信号，强度高于普通信号
2. 时效性：必须在30分钟内的连续信号才有效
3. 确认性：需要RSI和MACD同时背离才算，避免假信号
4. 价格幅度：需要至少0.1%的价格变化，过滤微小波动
